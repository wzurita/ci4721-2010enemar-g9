/**********************************************************************
 * Claire a parser generator.                                         *
 * Copyright (C) 1999  Paul Pacheco <93-25642@ldc.usb.ve>             *
 *                                                                    *
 * This library is free software; you can redistribute it and/or      *
 * modify it under the terms of the GNU Lesser General Public         *
 * License as published by the Free Software Foundation; either       *
 * version 2 of the License, or (at your option) any later version.   *
 *                                                                    *
 * This library is distributed in the hope that it will be useful,    *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
 * Lesser General Public License for more details.                    *
 *                                                                    *
 * You should have received a copy of the GNU Lesser General Public   *
 * License along with this library; if not, write to the Free         *
 * Software Foundation, Inc., 59 Temple Place, Suite 330,             *
 * Boston, MA  02111-1307  USA                                        *
 *                                                                    *
 * Please contact Paul Pacheco <93-25642@ldc.usb.ve> to submit any    *
 * suggestion or bug report.                                          *
 **********************************************************************/

/*
 * $Id: Parser.clr,v 1.1 1999/11/07 11:45:29 Paul Exp $
 *
 * the changes to this file are
 *
 * $Log: Parser.clr,v $
 * Revision 1.1  1999/11/07 11:45:29  Paul
 * Moved the syntax of regular expressions to regexp package
 *
 * Revision 1.1.1.1  1999/10/31 07:47:02  Paul
 * Imported Claire files
 *
 * Revision 1.2  1999/09/09 09:53:55  Paul
 * Added some cvs comments
 *
 */

package ve.usb.Claire.regexp.syntax;
import ve.usb.Claire.regexp.*;

/**
 * Parser creates a regular expresion object from a regular expression
 * @version     $Revision: 1.1 $
 * @author      Paul Pacheco <93-25642@ldc.usb.ve>
 * @since       JDK1.2
 */

public class Parser
{
		public Parser()
		{
		}
}

/*
%start binregexp, file

file: binregexp
{
	System.out.println($1.minimal());
} "\n" file
|
*/


<RE> binregexp:
binregexp "\|" negregexp
{
		$$ = $1.or($3);
}
| binregexp "\&" negregexp
{
		$$ = $1.and($3);
}
| binregexp "\^" negregexp
{
		$$ = $1.xor($3);
}
| binregexp '-' negregexp
{
		$$ = $1.minus($3);
}
| negregexp
{
	$$ = $1;
}

'-':"\-"

<RE>negregexp:
"\!" negregexp
{
	$$= $2.dontContain();
}
| concregexp
{
	$$ = $1;
}

<RE> concregexp:
concregexp unaryregexp
{
		$$ = $1.concat($2);
}
| unaryregexp
{
	$$ = $1;
}

<int> NUMBER: "[0-9]+"
{
	try
	{
		$$ = Integer.parseInt($1);
	}
	catch (Exception e)
	{
	}	
}
'{':"\{"
'}':"\}"
',':"\,"

<RE>unaryregexp:
unaryregexp "\?"
{
		$$ = $1.repeatTo(1);
}
| unaryregexp "\*"
{
		$$=$1.repeatFrom(0);
}
| unaryregexp "\+"
{
		$$= $1.repeatFrom(1);
}
| unaryregexp '{' NUMBER '}'
{
	$$ = $1.repeat($3);
}
| unaryregexp '{' NUMBER ',' '}'
{
	$$ = $1.repeatFrom($3);
}
| unaryregexp '{' NUMBER ',' NUMBER '}'
{
	$$ = $1.repeat($3,$5);
}
| singleregexp
{
	$$ = $1;
}

']':"\]"

<RE>singleregexp:
"\(" binregexp "\)"
{
	$$=$2;
}
| CH
{
	$$= RE.ch($1);
}
| "\."
{
	$$= RE.dot();
}
| "\[" range "\]"
{
	$$=$2;
}
| "\[\^" range ']'
{
	$$=RE.dot().minus($2);
}

<RE>range:
simplerange
{
	$$ = $1;
}
| range simplerange
{
	$$ = $1.or($2);
}


<RE> simplerange:
CH '-' CH
{
	$$ = RE.ch($1,$3);
}
| CH
{
	$$ = RE.ch($1);
}

<char> CH:
"\\u[0-9a-fA-F]{4}"
{
	Integer value=Integer.valueOf($1.substring(2), 16);	
	$$= (char)value.intValue();
}
| "\\[0-3]?[0-7]?[0-7]"
{
	Integer value=Integer.valueOf($1.substring(1), 8);	
	$$= (char)value.intValue();
}
| "\\b"
{
	$$ = '\b';
}
| "\\t"
{
	$$ = '\t';
}
| "\\n"
{
	$$ = '\n';
}
| "\\f"
{
	$$ = '\f';
}
| "\\r"
{
	$$ = '\r';
}
| "\\."
{
	$$ = $1.charAt(1);
}
| "."
{
	$$ = $1.charAt(0);
}
