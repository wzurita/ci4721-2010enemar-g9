/**********************************************************************
 * Claire a parser generator.                                         *
 * Copyright (C) 1999  Paul Pacheco <93-25642@ldc.usb.ve>             *
 *                                                                    *
 * This library is free software; you can redistribute it and/or      *
 * modify it under the terms of the GNU Lesser General Public         *
 * License as published by the Free Software Foundation; either       *
 * version 2 of the License, or (at your option) any later version.   *
 *                                                                    *
 * This library is distributed in the hope that it will be useful,    *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
 * Lesser General Public License for more details.                    *
 *                                                                    *
 * You should have received a copy of the GNU Lesser General Public   *
 * License along with this library; if not, write to the Free         *
 * Software Foundation, Inc., 59 Temple Place, Suite 330,             *
 * Boston, MA  02111-1307  USA                                        *
 *                                                                    *
 * Please contact Paul Pacheco <93-25642@ldc.usb.ve> to submit any    *
 * suggestion or bug report.                                          *
 **********************************************************************/

/*
 * $Id: State.java,v 1.2 1999/11/21 02:12:39 Paul Exp $
 *
 * the changes to this file are
 *
 * $Log: State.java,v $
 * Revision 1.2  1999/11/21 02:12:39  Paul
 * Dramatically reduced the size of the generated tables (suggested by Ascander Suarez)
 *
 * Revision 1.1.1.1  1999/10/31 07:47:02  Paul
 * Imported Claire files
 *
 * Revision 1.7  1999/10/09 01:59:14  Paul
 * Added some more performance improvments.
 * Fixed a small bug that caused some grammars not to work properly
 * Compression is now allways done
 *
 * Revision 1.6  1999/10/09 00:15:08  Paul
 * Several speed improvments
 *
 * Revision 1.5  1999/09/29 03:03:09  Paul
 * Improved compression speed just a little more
 *
 * Revision 1.4  1999/09/29 02:47:27  Paul
 * Drammatically improved the speed of the compression algorithm
 *
 * Revision 1.3  1999/09/09 12:20:23  Paul
 * Added some javadoc comments
 *
 * Revision 1.2  1999/09/09 09:53:55  Paul
 * Added some cvs comments
 *
 */
package ve.usb.Claire.contextFree;
import java.util.*;
import java.io.*;
import ve.usb.Claire.util.*;
import ve.usb.Claire.*;
import ve.usb.Claire.contextFree.symbol.*;

/**
 * State represents a state in the viable prefix automata
 * @Implements java.io.Serializable
 * @version     $Revision: 1.2 $
 * @author      Maria Eugenia Ahues
 * @author      Bernardo Munoz
 * @author      Rui Santos
 * @author      Paul Pacheco
 * @since       JDK1.2
 * @see Automata
 * @see Item
 */

public class State  implements Cloneable, Comparable, Repartitionable
{
	
      /**
       * represents the shifts and gotos for the state
       */
      private Map transitions=new HashMap();
      
      /**
       * represents the reduces for the state
       */
      private Map reduceTable=new HashMap();
      
      /**
       * contains a list of the items for this state
       */
      private List items=new ArrayList();
					
      /**
       * contains the id for this state
       */
      private short id;
      
      /**
       * contains a list of the initial items for this state.
       * two states are equals if they have the same initial items
       */
      private List initialItems=new ArrayList();
      

      /**
       * contains a list of conflicts generated by this state
       */
      private Collection conflicts;
      
      /**
       * Class constructor, creates an empty state
       */
      private State ()
      {
	 this.id=0;
      }		
      
      
      /** 
       * Class constructor with an Item, the item is the initial
       * item for this state
       */
      State (Item P)
      {
	 //addItem(P);			
	 items.add(P);
	 initialItems.add(P);
      }		
      

      /**
       * Gets the identifier of this State
       * @return int this identifier
       */
      public short getId ()
      {
	 return this.id;
      }
      
      /**
       * Sets the identifier of this State
       * @param id Identifier 
       * @return int this identifier
       */
      void setId (short id)
      {
	 this.id = id;
      }
      
      /**
       * Gets the items for this state,
       * the state has to be expanded first, or not all of the items
       * will be returned;
       * @return the items of this state
       * @see expand
       */		
      Iterator iterator ()
      {
	 return items.iterator();
      }
						

      /**
       * get the set of rules of this state
       * @return the set containing the rules this state has
       */
      public Set rules()
      {
	 Set result = new HashSet();
	 Iterator iter = iterator();
	 while (iter.hasNext())
	 {
	    Item item = (Item)iter.next();
	    result.add(item.getRule());
	 }
	 return result;
      }
		
      /**
		 * get the set of rules of this state
		 * @return the set containing the rules this state has
		 */
      public Set initialRules()
      {
	 Set result = new HashSet();
	 Iterator iter = initialItems.iterator();
	 while (iter.hasNext())
	 {
	    Item item = (Item)iter.next();
	    result.add(item.getRule());
	 }
	 return result;
      }
		
      /**
		 * expands an item, and adds more items to this state
		 * @param parentItem the item been expanded
		 * @param ps the productions of the grammar
		 * @param true if one of the previows items were modified		 
		 */
      private boolean expandItem(Item parentItem, Grammar grammar)
      {

	 Symbol nextSymbol=parentItem.getAfterDot();
			
			
			
	 if (nextSymbol != null && nextSymbol.isNonTerminal())
	 {
	    Collection rulesWith= grammar.getRulesWith(nextSymbol);

	    boolean result= addItems(rulesWith,parentItem);
	    return result;
	 }
			
	 return false;
      }
					
		
      /**
       * expand this state, generates the child states, and
       * determines the shift and reduce actions
       * @param ps the productions of the grammar
       */
      
		
      void expand(Grammar grammar)
      {

	 boolean cambio=false;

	 conflicts = new ArrayList();

	 isCalculated=false;			
			
	 do
	 {
	    cambio=false;

	    for (int i=0;i< items.size();i++)
	    {
	       Item item= (Item)items.get(i);
	       cambio=expandItem(item,grammar) || cambio;
	    }
	 }
	 while (cambio);


	 Item defaultReduce=defaultReduce();
			
	 if (defaultReduce!=null)
	 {
	    defaultReduce.getRule().reduced(true);
	 }

			
	 Iterator enum = items.iterator();

	 while (enum.hasNext())
	 {
	    Item item=(Item)enum.next();
				
	    if (defaultReduce==null && item.last())
	       addReduce(item);
	    else if (!item.last())
	       addShift(item);
	 }
			

      }
		
      /**
		 * replaces a shift transition,
		 * @param sym the symbol under we are making shift
		 * @param state the new state to where we are going
		 */		
      void put(Symbol sym, State state)
      {
	 transitions.put(sym,state);
      }

      /**
       * gets the collection of conflicts generated by this state
       * @return the collection of conflicts
       */
      Collection conflicts()
      {
	 return this.conflicts;
      }
      
      /**
       * solves the conflicts in the state.
       * @param item the item that generated the acction
       * @param thisIsShift true if the action that wants to be added is shift
       * @param sym the symbol under where we are taking actions
       * @return true if the action should be carried out
       */
      private boolean solveConflict(Item item, boolean thisIsShift, Symbol sym)
      {
	 Item prevRule=(Item)reduceTable.get(sym);

	 // if there was'nt any action do the action
	 if (prevRule == null)
	    return true;

	 boolean prevIsShift=transitions.containsKey(sym);

	 // if both actions were shift, then the next state contains the combination of both states
	 if (thisIsShift && prevIsShift)
	    return true;

	 // if both are reduce, with the same production, substitute
	 if (!thisIsShift && !prevIsShift && item.getRule().equals(prevRule))
	    return true;


	 // Ok. we have a conflict. Lets see if precedence solves it

	 if (prevRule.precedence() != Rule.NOPREC &&
	     item.precedence() != Rule.NOPREC)
	 {
	    if (prevRule.precedence() < item.precedence())
	       return false;
	    else if (prevRule.precedence() > item.precedence())
	       return true;
	    else if (item.asocLeft())
	       return !thisIsShift;
	    else if (item.asocRight())
	       return thisIsShift;
	 }
	 else if (prevRule.getRule().equals(item.getRule()))
	 {
	    if (item.asocLeft())
	       return !thisIsShift;
	    else if (item.asocRight())
	       return thisIsShift;
	 }
			
	 Conflict conflict = new Conflict(prevRule, item, this, sym);

	 conflicts.add(conflict);

	 return conflict.solve() == 2;
	 
	 
      }					
			
      /**
       * Adds a reduce action
       * @param item, the item been reduced
       */
      private void addReduce(Item item)
      {

	 Iterator iter = item.getLah().iterator();

	 while (iter.hasNext())
	 {
	    Symbol lookAheadSymbol=(Symbol)iter.next();

	    if (solveConflict(item,false,lookAheadSymbol))
	    {
	       reduceTable.put(lookAheadSymbol,item);
	       transitions.remove(lookAheadSymbol);
	       item.getRule().reduced(true);
	    }
	 }
      }


      /**
		 * adds a shift transition
		 * @param item the item under where we are making shift
		 */
      private void addShift(Item item)
      {
	 Symbol sym=item.getAfterDot();

	 if (solveConflict(item,true,sym))
	 {
				
	    Item newItem=(Item)item.clone();
	    newItem.advance();

	    State nextState=(State)transitions.get(sym);

	    if (nextState==null)
	    {
	       nextState=new State(newItem);
	       transitions.put(sym,nextState);
	       reduceTable.put(sym,item);
	    }
	    else
	       nextState.addItem(newItem);
	 }
      }

      /**
		 * gets the state to where a shift is to be carried out
		 * @param sym the symbol under where we are making shift
		 * @return the state to where the shift is to be done
		 */
      public State getTransition(Symbol sym)
      {
	 return (State)transitions.get(sym);
      }

      /**
		 * gets the production that we have to reduce
		 * @param sym the symbol in where we are making the reduce
		 * @return the production that has to be reduced
		 */
      public Rule getReduction(Symbol sym)
      {
	 Item defaultReduce=defaultReduce();
			
	 if (defaultReduce!=null)
	    return defaultReduce.getRule();
				
	 return ((Item)reduceTable.get(sym)).getRule();
      }
		
		
      /**
		 * Adds Items to this State. 
		 * @param ps List of grammar productions
		 * @param psc List of productions to be added
		 * @param P Item from which this productions are going to be added. The look a hed of the productions that are added is calculated from this State Rule
		 * @return boolean true if productions were inserted, false if not
		 */
      boolean addItem(Item next)
      {			
			
	 Iterator iter = items.iterator();


	 while (iter.hasNext())
	 {
	    Item equalItem = (Item)iter.next();

	    if (equalItem.compareProd (next))
	       return equalItem.appendLah (next);
				
	 }
			
	 if (next.getDot() > 0)
	    initialItems.add(next);

	 isCalculated=false;
	 this.items.add(next);

			
	 return false;
			
      }
		
      /**
		 * adds a list of items to this state
		 * @param prods the productions that have to be added
		 * @param parentItem the item that generated the expansion
		 * @return true if a item has been modified
		 */
      static int count=0;
		
      private boolean addItems (Collection prods, Item parentItem)
      {
	 boolean modified = false;

				

	 Iterator iter=prods.iterator();
			
	 while (iter.hasNext())
	 {
	    Rule prod = (Rule)iter.next();
				
	    Item item = new Item (prod);
				
	    item.calcLookAHead (parentItem);
				
	    modified = addItem(item) || modified;
				
	 }

			
	 return modified;

      }
  
      /**
		 * test to see if a state is equal to another state
		 * @param state the other state to whitch we are comparing
		 * @return true if the states are equal
		 */
      public boolean equals (Object state)
      {
	 if (!(state instanceof State))
	    return false;
			

	 List otherInitials=((State)state).initialItems;

	 if (initialItems.size() != otherInitials.size())
	    return false;

			
	 if (initialItems.containsAll(otherInitials))
	    return true;
							 
	 if (initialItems.size() != 1)
	    return false;

	 Item myDefault= (Item)initialItems.get(0);
	 Item hisDefault=(Item)otherInitials.get(0);

	 if (!myDefault.last() || !hisDefault.last())
	    return false;

	 return myDefault.compareProd(hisDefault);
      }

      /**
		 * determines if the state has a default reduce
		 * @return true if the state has a default reduce
		 */
      public boolean hasDefaultReduce()
      {
	 return defaultReduce()!= null;
      }

      /**
		 * gets the identifier of the default reduce
		 * @return the identifier of the rule that is reduced by default
		 */
      public int defaultReduceId()
      {
	 return defaultReduce().getId();
      }

      private Item calculatedDefaultReduce=null;
      private boolean isCalculated=false;
      /**
		 * return the default reduce for this state
		 * @return the item reduced. null otherwise
		 */
      Item defaultReduce()
      {
	 /*if (initialItems.size()!=1)
	   return null;*/
	 if (isCalculated)
	    return calculatedDefaultReduce;

	 isCalculated=true;
			
	 Iterator iter = items.iterator();

	 Item defaultReduce= null;
			
	 while (iter.hasNext())
	 {

	    Item next = (Item)iter.next();

	    if (next.last())
	    {
	       if (defaultReduce != null)
		  return null;

	       defaultReduce= next;
	    }
	    else if (next.getAfterDot().isTerminal())
	       return null;
	 }

	 calculatedDefaultReduce=defaultReduce;
			
	 return defaultReduce;
			
      }

      /**
		 * Converts this object to String
		 * @return String this object to string
		 */  
      public String toString ()
      {

	 StringWriter swriter = new StringWriter();
	 PrintWriter out = new PrintWriter(swriter);
		   
	 out.println("STATE "+id);
	 out.println("RULES:");
	 out.println(items);
	 out.println("TRANSITIONS:");
			
	 Iterator e=transitions.keySet().iterator();
		   
	 while (e.hasNext())
	 {
	    Symbol s=(Symbol)e.next();
	    out.println(s + "(" + s.getId()+") -> " +((State)transitions.get(s)).getId());
	 }
	 out.println("REDUCTIONS:");
		   
	 Item defaultReduce=defaultReduce();
		   
	 if (defaultReduce!=null)
	    out.println("* :  " + defaultReduce);
	 else
	 {
	    Set reduceSymbols=reduceSymbols();
	    Iterator iter=reduceSymbols.iterator();
		      
	    while (iter.hasNext())
	    {
	       Symbol sym=(Symbol)iter.next();
			 
	       out.println(sym + "(" + sym.getId()+") :   " + getReduction(sym));
	    }
	 }
		   
	 if (!conflicts.isEmpty())
	 {
	    out.println("CONFLICTS:");
	    Iterator iter = conflicts.iterator();
	    while (iter.hasNext())
	       out.println(iter.next());
	 }

	 out.close();
		   
	 return swriter.toString();
      }

      /**
		 * makes a clone of this state
		 * @return the clone of this state
		 */
      public Object clone()
      {
	 State newState=new State();
	 newState.transitions.putAll(transitions);
	 newState.reduceTable.putAll(reduceTable);			
	 newState.items.addAll(items);
	 newState.id=id;
	 return newState;
      }			

      /**
		 * returns the states to where this state perform shifts
		 * @return the states to where a shift is done
		 */
      Collection childStates()
      {
	 return transitions.values();
      }


      /**
		 * return all the symbols that this state uses. if this state has a default
		 * reduce, then this method is not accurate
		 * @return all the symbols that this state uses
		 */
      public Set symbols()
      {
	 return reduceTable.keySet();
      }

      /**
		 * determines if the state accepts end of file
		 * @return true if the state does something with eof
		 *         false otherwise
		 */
      public boolean acceptEOF()
      {
	 return reduceTable.containsKey(Automata.eofSym);
      }
		
      /**
		 * gives the list of terminal symbol with wich some action is taken
		 * @return the list of terminal symbols with wich shift or reduce are taken		 
		 */
      public Set terminalSymbols()
      {
	 Set result= new HashSet();
	 Iterator iter = reduceTable.keySet().iterator();

	 while (iter.hasNext())
	 {
	    Symbol sym = (Symbol) iter.next();
	    if (sym.isTerminal())
	       result.add(sym);
	 }
	 return result;
      }
		
      /**			
		 * returns all the symbols that this state uses for thransition
		 * @return the transition symbols
		 */
      public Set transitionSymbols()
      {
	 return transitions.keySet();
      }


      /**
		 * gets a list of the transitions done by this state
		 * @return the map representing the transitions
		 */
      Map transitions()
      {
	 return Collections.unmodifiableMap(transitions);
      }
		
      /**
		 * returns the symbols that perform a shift
		 * @return the symbols that perform a reduce
		 */
      public Set shiftSymbols()
      {
	 Iterator shifts=transitions.keySet().iterator();
			
	 Set result=new HashSet();
			
	 while (shifts.hasNext())
	 {
	    Symbol sym=(Symbol)shifts.next();

	    if (sym.isTerminal())
	       result.add(sym);
	 }

	 return result;
      }

      /**
		 * gets the symbols that perform a goto
		 * @return the symbols that perform a goto
		 */
      public Set gotoSymbols()
      {
	 Iterator shifts=transitions.keySet().iterator();
			
	 Set result=new HashSet();
			
	 while (shifts.hasNext())
	 {
	    Symbol sym=(Symbol)shifts.next();

	    if (!sym.isTerminal())
	       result.add(sym);
	 }

	 return result;
      }

      /**
		 * get the symbols that perform a reduce
		 * @return the list of symbols that perform a reduce
		 */
      Set reduceSymbols()
      {

	 Iterator keys=reduceTable.keySet().iterator();
	 Set result=new HashSet();
			
	 while (keys.hasNext())
	 {
	    Object next=keys.next();
	    if (!transitions.containsKey(next))
	       result.add(next);				
	 }

	 return result;
      }

      /**
		 * determines if the state can be merged with other state
		 * under the compression algorithm
		 * @param other the other symbol
		 * @param part the partition that contain the classes
		 */
      public boolean sameClass(Repartitionable other, Partition part)
      {
	 State otherState= (State)other;

	 if (this==otherState)
	    return true;

	 if (this.items.size() != otherState.items.size())
	    return false;
			
	 if (otherState.transitions.size() != transitions.size())
	    return false;

	 if (otherState.reduceTable.size() != reduceTable.size())
	    return false;

	 if (defaultReduce()!= null || otherState.defaultReduce()!=null)
	    return false;
			
	 Iterator iter= reduceTable.entrySet().iterator();

	 while (iter.hasNext())
	 {
	    Map.Entry entry= (Map.Entry)iter.next();

	    Symbol sym= (Symbol)entry.getKey();
	    Item item= (Item)entry.getValue();

	    State myTrans= (State)transitions.get(sym);
	    State hisTrans= (State)otherState.transitions.get(sym);
				
	    if (! part.sameClass(myTrans, hisTrans))
	       return false;

				
	    if (myTrans==null)
	    {
	       Item otherItem = (Item) otherState.reduceTable.get(sym);

	       if (otherItem == null)
		  return false;
					
	       if (!item.compareProd(otherItem))
		  return false;
	    }
				
	 }
	 return true;
      }

      /**
		 * update pointers to compressed states
		 * @param map the map that tells who to compress with
		 */
      public void compress(Map map)
      {
	 Map newTrans= new HashMap();

	 Iterator iter= transitions.entrySet().iterator();
	 while (iter.hasNext())
	 {
	    Map.Entry entry= (Map.Entry)iter.next();

	    Symbol sym= (Symbol)entry.getKey();
	    State state= (State)entry.getValue();

	    newTrans.put(sym,map.get(state));
	 }

	 transitions=newTrans;
      }
		
      /**
		 * compares two states so they can be ordered and the biggest state
		 * would be ubicated first
		 */
      public int compareTo(Object other)
      {
	 State otherState=(State)other;

	 if (reduceTable.size() < otherState.reduceTable.size())
	    return 1;

	 if (reduceTable.size() > otherState.reduceTable.size())
	    return -1;

	 return 0;
      }
		
      /**
		 * gets a hashCode for the state
		 * @return a hashcode for the state
		 */
      public int hashCode()
      {
	 int hashCode=0;
			
	 Iterator enum=initialItems.iterator();
			
	 while (enum.hasNext())
	 {
	    hashCode+=enum.next().hashCode();
	 }

	 return hashCode;
      }
}


